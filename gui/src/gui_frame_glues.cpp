#include "lxgui/gui_frame.hpp"
#include "lxgui/gui_backdrop.hpp"
#include "lxgui/gui_region.hpp"
#include "lxgui/gui_fontstring.hpp"
#include "lxgui/gui_texture.hpp"
#include "lxgui/gui_manager.hpp"
#include "lxgui/gui_out.hpp"
#include "lxgui/gui_uiobject_tpl.hpp"

#include <sol/state.hpp>

/** A @{UIObject} that can contain other objects and react to events.
*   This class, which is at the core of the UI design, can contain
*   other @{Frame}s as "children", and @{LayeredRegion}s sorted by layers
*   (text, images, ...). A frame can also react to events, and register
*   callbacks to be executed on particular events (key presses, etc.)
*   or on every tick.
*
*   Each frame has an optional "title region", which can be used to
*   define and draw a title bar. This title bar can then be used to
*   move the frame around the screen using mouse click and drag.
*   Furthermore, frames have optional support for resizing by click
*   and drag on corners or edges (opt in).
*
*   Frames can either move freely on the screen, or be "clamped" to the
*   screen so they cannot be partly outside of their render area.
*
*   __Rendering.__ Frames are grouped into different "strata", which are
*   rendered sequentially. Frames in a high strata will always be rendered
*   above frames in a low strata. Then, within a strata, frames are further
*   sorted by "level"; within this particular strata, a frame with a high
*   level will always be rendered above all frames with a lower level, but
*   it will still remain below other frames in a higher strata. The level
*   of a frame is automatically set to the maximum level inside the strata
*   when the frame is clicked, which effectively brings the frame to the
*   front.
*
*   __Children and regions.__ When a frame is hidden, all its children
*   and regions will also be hidden. Likewise, deleting a frame will
*   automatically delete all its children and regions, unless they are
*   detached first. Other than this, children and regions do not need to
*   be located inside the frame; this is controlled purely by their anchors.
*   Therefore, if a child is not anchored to its parent, moving the parent
*   will not automatically move the child.
*
*   __Events.__ Frames can react to events. For this to happen, a callback
*   function must be registered to handle the corresponding event. There are
*   two types of events. First: hard-coded UI events such as `OnKeyPress`
*   or `OnUpdate`, which are automatically triggered by lxgui. Second:
*   generic events, which can be triggered from various sources and all
*   forwarded to the `OnEvent` callback. Generic events are typically
*   generated by whatever application is being driven by lxgui (i.e., your
*   game), and they enable application-specific behavior (for example:
*   changing the UI when the player is under attack will likely require an
*   `"UNDER_ATTACK"` event).
*
*   To use the first type of events (hard-coded events), all you have to
*   do in general is register a callback function using @{Frame:add_script}
*   or @{Frame:set_script}. However, some hard-coded events require explicit
*   enabling. In particular:
*
*   - Events related to keyboard input (`OnKeyDown`, `OnKeyUp`) require
*   @{Frame:enable_keyboard}.
*   - Events related to mouse input (`OnDragStart`, `OnDragStop`,`OnEnter`,
*   `OnLeave`, `OnMouseUp`, `OnMouseDown`, `OnMouseWheel`, `OnReceiveDrag`)
*   require @{Frame:enable_mouse}.
*
*   To use the second type of events (generic events), you have to register
*   a callback for `OnEvent` _and_ register the frame for each generic event
*   you wish to listen to. This is done with @{Frame:register_event}.
*
*   Some events provide arguments to the registered callback function. For
*   example, the application can fire a `"UNIT_ATTACKED"` event when a unit
*   is under attack, and pass the ID of the attacked unit as a first argument,
*   and the ID of the attacker as a second argument. If a callback
*   function is registered using @{Frame:add_script} or @{Frame:set_script},
*   these arguments can be handled and named like regular function parameters.
*   In XML callback handlers, they can be accessed with the hard-coded generic
*   names `arg1`, `arg2`, etc.
*
*   Hard-coded events available to all @{Frame}s:
*
*   - `OnDragStart`: Triggered when one of the mouse button registered for
*   dragging (see @{Frame:register_for_drag}) has been pressed inside the
*   area of the screen occupied by the frame, and a mouse movement is first
*   recorded.
*   - `OnEnter`: Triggered when the mouse pointer enters into the area of
*   the screen occupied by the frame. Note: this only takes into account the
*   position and size of the frame and its title region, but not the space
*   occupied by its children or layered regions. Will not trigger if the
*   frame is hidden.
*   - `OnEvent`: Triggered when a registered generic event occurs. See
*   @{Frame:register_event}. To allow distinguishing which event has just
*   been fired, the registered callback function is always provided with a
*   first argument that is set to a string matching the event name. Further
*   arguments can be passed to the callback and are handled as for other events.
*   - `OnHide`: Triggered when @{UIObject:hide} is called, or when the frame
*   is hidden indirectly (for example if its parent is itself hidden). This
*   will only fire if the frame was previously shown.
*   - `OnKeyDown`: Triggered when any keyboard key is pressed. Will not
*   trigger if the frame is hidden. This event provides two arguments to
*   the registered callback: a number identifying the key, and the
*   human-readable name of the key.
*   - `OnKeyUp`: Triggered when any keyboard key is released. Will not
*   trigger if the frame is hidden. This event provides two arguments to
*   the registered callback: a number identifying the key, and the
*   human-readable name of the key.
*   - `OnLeave`: Triggered when the mouse pointer leaves the area of the
*   screen occupied by the frame. Note: this only takes into account the
*   position and size of the frame and its title region, but not the space
*   occupied by its children or layered regions. Will not trigger if the
*   frame is hidden, unless the frame was just hidden with the mouse
*   previously inside the frame.
*   - `OnLoad`: Triggered just after the frame is created. This is where
*   you would normally register for events and specific inputs, set up
*   initial states for extra logic, or do localization. When this event is
*   triggered, you can assume that all the frame's regions and children
*   have already been loaded. The same is true for other frames and regions
*   that are defined *earlier* in the same XML file, and those that are
*   defined in an addon listed *earlier* than the current addon in the
*   'addons.txt' file. In all other cases, frames or regions will not yet
*   be loaded when `OnLoad` is called, hence they cannot be refered to
*   (directly or indirectly).
*   - `OnMouseDown`: Triggered when any mouse button is pressed. Will not
*   trigger if the frame is hidden. This event provides one argument to
*   the registered callback: a string identifying the mouse button
*   (`"LeftButton"`, `"RightButton"`, or `"MiddleButton"`).
*   - `OnMouseUp`: Triggered when any mouse button is released. Will not
*   trigger if the frame is hidden. This event provides one argument to
*   the registered callback: a string identifying the mouse button
*   (`"LeftButton"`, `"RightButton"`, or `"MiddleButton"`).
*   - `OnMouseWheel`: Triggered when the mouse wheel is moved. This event
*   provides one argument to the registered callback: a number indicating by
*   how many "notches" the wheel has turned in this event. A positive value
*   means the wheel has been moved "away" from the user (this would normally
*   scroll *up* in a document).
*   - `OnReceiveDrag`: Triggered when the mouse pointer was previously
*   dragged onto the frame, and when one of the mouse button registered for
*   dragging (see @{Frame:register_for_drag}) is released. This enables
*   the "drop" in "drag and drop" operations.
*   - `OnShow`: Triggered when @{UIObject:show} is called, or when the frame
*   is shown indirectly (for example if its parent is itself shown). This
*   will only fire if the frame was previously hidden.
*   - `OnSizeChanged`: Triggered whenever the size of the frame changes, either
*   directly or indirectly. Be very careful not to call any function that could
*   change the size of the frame inside this callback, as this would generate
*   an infinite loop.
*   - `OnUpdate`: Triggered on every tick of the game loop. This event provides
*   one argument to the registered callback: a floating point number indicating
*   how much time has passed since the last call to `OnUpdate` (in seconds).
*   For optimal performance, prefer using other events types whenever possible.
*   `OnUpdate` callbacks will be executed over and over again, and can quickly
*   consume a lot of resources if user unreasonably. If you have to use
*   `OnUpdate`, you can mitigate performance problems by artificially reducing
*   the update rate: let the callback function only accumulate the time passed,
*   and wait until enough time has passed (say, half a second) to execute any
*   expensive operation. Then reset the accumulated time, and wait again.
*
*   Generic events fired natively by lxgui:
*
*   - `"LUA_ERROR"`: Triggered whenever a callback function or an addon script
*   file generates a Lua error. This event provides one argument to the
*   registered callback: a string containing the error message.
*   - `"ADDON_LOADED"`: Triggered when an addon is fully loaded. This event
*   provides one argument to the registered callback: a string containing the
*   name of the loaded addon.
*   - `"ENTERING_WORLD"`: Triggered once at the start of the program, at the
*   end of the first update tick.
*
*   __Virtual frames.__ Virtual frames are not displayed on the screen,
*   and technically are not part of the interface. They are only available
*   as "templates" that can be reused by other (virtual or non-virtual)
*   frames. This is useful for defining a few frame templates with a
*   particular style, and then reuse these templates across the interface
*   to ensure a consistent look. When inheriting from a virtual frame,
*   the inheriting frame will copy all the registered callbacks, all the
*   child frames, and all the layered regions of the virtual frame.
*
*   This inheritance mechanism can be chained: a virtual frame itself can
*   inherit from another virtual frame. It is also possible to inherit from
*   multiple virtual frames at once, which will copy their respective content
*   in the order they are specified.
*
*   Inherits all methods from: @{UIObject}.
*
*   Child classes: @{Button}, @{CheckButton}, @{FocusFrame}, @{EditBox},
*   @{ScrollFrame}, @{Slider}, @{StatusBar}.
*   @classmod Frame
*/

namespace lxgui {
namespace gui
{

void frame::register_on_lua(sol::state& mLua)
{
    auto mClass = mLua.new_usertype<frame>("Frame",
        sol::base_classes, sol::bases<uiobject>(),
        sol::meta_function::index,
        &frame::set_lua_member_,
        sol::meta_function::new_index,
        &frame::get_lua_member_);

    /** @function add_script
    */
    mClass.set_function("add_script", [](frame& mSelf, const std::string& sName,
        sol::protected_function mFunc)
    {
        mSelf.add_script(sName, std::move(mFunc));
    });

    /** @function create_font_string
    */
    mClass.set_function("create_font_string", [](frame& mSelf, const std::string& sName,
        sol::optional<std::string> sLayer, sol::optional<std::string> sInheritance)
    {
        layer_type mLayer = layer_type::ARTWORK;
        if (sLayer.has_value())
            mLayer = layer::get_layer_type(sLayer.value());

        return mSelf.create_region<font_string>(
            mLayer, sName,
            mSelf.get_manager().get_virtual_uiobject_list(sInheritance.value_or(""))
        );
    });

    /** @function create_texture
    */
    mClass.set_function("create_texture", [](frame& mSelf, const std::string& sName,
        sol::optional<std::string> sLayer, sol::optional<std::string> sInheritance)
    {
        layer_type mLayer = layer_type::ARTWORK;
        if (sLayer.has_value())
            mLayer = layer::get_layer_type(sLayer.value());

        return mSelf.create_region<texture>(
            mLayer, sName,
            mSelf.get_manager().get_virtual_uiobject_list(sInheritance.value_or(""))
        );
    });

    /** @function create_title_region
    */
    mClass.set_function("create_title_region", member_function<&frame::create_title_region>());

    /** @function disable_draw_layer
    */
    mClass.set_function("disable_draw_layer", [](frame& mSelf, const std::string& sLayer)
    {
        mSelf.disable_draw_layer(layer::get_layer_type(sLayer));
    });

    /** @function enable_draw_layer
    */
    mClass.set_function("enable_draw_layer", [](frame& mSelf, const std::string& sLayer)
    {
        mSelf.enable_draw_layer(layer::get_layer_type(sLayer));
    });

    /** @function enable_keyboard
    */
    mClass.set_function("enable_keyboard", member_function<&frame::enable_keyboard>());

    /** @function enable_mouse
    */
    mClass.set_function("enable_mouse", [](frame& mSelf, bool bEnable,
        sol::optional<bool> bWorldAllowed)
    {
        mSelf.enable_mouse(bEnable, bWorldAllowed.value_or(false));
    });

    /** @function enable_mouse_wheel
    */
    mClass.set_function("enable_mouse_wheel", member_function<&frame::enable_mouse_wheel>());

    /** @function get_backdrop
    */
    mClass.set_function("get_backdrop", [](frame& mSelf) -> sol::optional<sol::table>
    {
        backdrop* pBackdrop = mSelf.get_backdrop();
        if (!pBackdrop)
            return sol::nullopt;

        sol::table mReturn = mSelf.get_manager().get_lua().create_table();

        mReturn["bgFile"] = pBackdrop->get_background_file();
        mReturn["edgeFile"] = pBackdrop->get_edge_file();
        mReturn["tile"] = pBackdrop->is_background_tilling();

        mReturn["tileSize"] = pBackdrop->get_tile_size();
        mReturn["edgeSize"] = pBackdrop->get_edge_size();

        const auto& lInsets = pBackdrop->get_background_insets();
        mReturn["insets"]["left"] = lInsets.left;
        mReturn["insets"]["right"] = lInsets.right;
        mReturn["insets"]["top"] = lInsets.top;
        mReturn["insets"]["bottom"] = lInsets.bottom;

        return std::move(mReturn);
    });

    /** @function get_backdrop_border_color
    */
    mClass.set_function("get_backdrop_border_color", [](frame& mSelf)
        -> sol::optional<std::tuple<float, float, float, float>>
    {
        if (!mSelf.get_backdrop())
            return sol::nullopt;

        const color& mColor = mSelf.get_backdrop()->get_edge_color();
        return std::make_tuple(mColor.r, mColor.g, mColor.b, mColor.a);
    });

    /** @function get_backdrop_color
    */
    mClass.set_function("get_backdrop_color", [](frame& mSelf)
        -> sol::optional<std::tuple<float, float, float, float>>
    {
        if (!mSelf.get_backdrop())
            return sol::nullopt;

        const color& mColor = mSelf.get_backdrop()->get_background_color();
        return std::make_tuple(mColor.r, mColor.g, mColor.b, mColor.a);
    });

    /** @function get_children
    */
    mClass.set_function("get_children", [](frame& mSelf)
    {
        std::vector<utils::observer_ptr<frame>> lChildren;
        lChildren.reserve(mSelf.get_rough_num_children());

        for (auto& mChild : mSelf.get_children())
        {
            lChildren.push_back(observer_from(&mChild));
        }

        return sol::as_table(std::move(lChildren));
    });

    /** @function get_effective_alpha
    */
    // mClass.set_function("get_effective_alpha", [](frame& mSelf)
    // {
    //     if (!check_object_())
    //         return 0;

    //     lua::function mFunc("Frame:get_effective_alpha", pLua, 1);

    //     mFunc.push(mSelf.get_effective_alpha());

    //     return mFunc.on_return();
    // }

    // /** @function get_effective_scale
    // */
    // mClass.set_function("get_effective_scale", [](frame& mSelf)
    // {
    //     if (!check_object_())
    //         return 0;

    //     lua::function mFunc("Frame:get_effective_scale", pLua, 1);

    //     mFunc.push(mSelf.get_effective_scale());

    //     return mFunc.on_return();
    // }

    // /** @function get_frame_level
    // */
    // mClass.set_function("get_frame_level", [](frame& mSelf)
    // {
    //     if (!check_object_())
    //         return 0;

    //     lua::function mFunc("Frame:get_frame_level", pLua, 1);

    //     mFunc.push(mSelf.get_level());

    //     return mFunc.on_return();
    // }

    // /** @function get_frame_strata
    // */
    // mClass.set_function("get_frame_strata", [](frame& mSelf)
    // {
    //     if (!check_object_())
    //         return 0;

    //     lua::function mFunc("Frame:get_frame_strata", pLua, 1);

    //     frame_strata mStrata = mSelf.get_frame_strata();
    //     std::string sStrata;

    //     if (mStrata == frame_strata::BACKGROUND)
    //         sStrata = "BACKGROUND";
    //     else if (mStrata == frame_strata::LOW)
    //         sStrata = "LOW";
    //     else if (mStrata == frame_strata::MEDIUM)
    //         sStrata = "MEDIUM";
    //     else if (mStrata == frame_strata::HIGH)
    //         sStrata = "HIGH";
    //     else if (mStrata == frame_strata::DIALOG)
    //         sStrata = "DIALOG";
    //     else if (mStrata == frame_strata::FULLSCREEN)
    //         sStrata = "FULLSCREEN";
    //     else if (mStrata == frame_strata::FULLSCREEN_DIALOG)
    //         sStrata = "FULLSCREEN_DIALOG";
    //     else if (mStrata == frame_strata::TOOLTIP)
    //         sStrata = "TOOLTIP";

    //     mFunc.push(sStrata);

    //     return mFunc.on_return();
    // }

    // /** @function get_frame_type
    // */
    // mClass.set_function("get_frame_type", [](frame& mSelf)
    // {
    //     if (!check_object_())
    //         return 0;

    //     lua::function mFunc("Frame:get_frame_type", pLua, 1);

    //     mFunc.push(mSelf.get_frame_type());

    //     return mFunc.on_return();
    // }

    // /** @function get_hit_rect_insets
    // */
    // mClass.set_function("get_hit_rect_insets", [](frame& mSelf)
    // {
    //     if (!check_object_())
    //         return 0;

    //     lua::function mFunc("Frame:get_hit_rect_inset", pLua, 4);

    //     const bounds2f& lInsets = mSelf.get_abs_hit_rect_insets();

    //     mFunc.push(lInsets.left);
    //     mFunc.push(lInsets.right);
    //     mFunc.push(lInsets.top);
    //     mFunc.push(lInsets.bottom);

    //     return mFunc.on_return();
    // }

    // /** @function get_id
    // */
    // mClass.set_function("get_id", [](frame& mSelf)
    // {
    //     if (!check_object_())
    //         return 0;

    //     lua::function mFunc("Frame:get_id", pLua, 1);

    //     mFunc.push(mSelf.get_id());

    //     return mFunc.on_return();
    // }

    // /** @function get_max_resize
    // */
    // mClass.set_function("get_max_resize", [](frame& mSelf)
    // {
    //     if (!check_object_())
    //         return 0;

    //     lua::function mFunc("Frame:get_max_resize", pLua, 2);

    //     vector2f lMax = mSelf.get_max_resize();

    //     mFunc.push(lMax.x);
    //     mFunc.push(lMax.y);

    //     return mFunc.on_return();
    // }

    // /** @function get_min_resize
    // */
    // mClass.set_function("get_min_resize", [](frame& mSelf)
    // {
    //     if (!check_object_())
    //         return 0;

    //     lua::function mFunc("Frame:get_min_resize", pLua, 2);

    //     vector2f lMin = mSelf.get_min_resize();

    //     mFunc.push(lMin.x);
    //     mFunc.push(lMin.y);

    //     return mFunc.on_return();
    // }

    // /** @function get_num_children
    // */
    // mClass.set_function("get_num_children", [](frame& mSelf)
    // {
    //     if (!check_object_())
    //         return 0;

    //     lua::function mFunc("Frame:get_num_children", pLua, 1);

    //     mFunc.push(mSelf.get_num_children());

    //     return mFunc.on_return();
    // }

    // /** @function get_num_regions
    // */
    // mClass.set_function("get_num_regions", [](frame& mSelf)
    // {
    //     if (!check_object_())
    //         return 0;

    //     lua::function mFunc("Frame:get_num_regions", pLua, 1);

    //     mFunc.push(mSelf.get_num_regions());

    //     return mFunc.on_return();
    // }

    // /** @function get_scale
    // */
    // mClass.set_function("get_scale", [](frame& mSelf)
    // {
    //     if (!check_object_())
    //         return 0;

    //     lua::function mFunc("Frame:get_scale", pLua, 1);

    //     mFunc.push(mSelf.get_scale());

    //     return mFunc.on_return();
    // }

    // /** @function get_script
    // */
    // mClass.set_function("get_script", [](frame& mSelf)
    // {
    //     if (!check_object_())
    //         return 0;

    //     lua::function mFunc("Frame:get_script", pLua, 1);
    //     mFunc.add(0, "script name", lua::type::STRING);
    //     if (mFunc.check())
    //     {
    //         std::string sScriptName = mFunc.get(0)->get_string();
    //         if (mSelf.has_script(sScriptName))
    //         {
    //             mFunc.notify_pushed();
    //         }
    //     }

    //     return mFunc.on_return();
    // }

    // /** @function get_title_region
    // */
    // mClass.set_function("get_title_region", [](frame& mSelf)
    // {
    //     if (!check_object_())
    //         return 0;

    //     lua::function mFunc("Frame:get_title_region", pLua, 1);

    //     if (mSelf.get_title_region())
    //     {
    //         mSelf.get_title_region()->push_on_lua(mFunc.get_state());
    //         mFunc.notify_pushed();
    //     }
    //     else
    //         mFunc.push_nil();

    //     return mFunc.on_return();
    // }

    // /** @function has_script
    // */
    // mClass.set_function("has_script", [](frame& mSelf)
    // {
    //     if (!check_object_())
    //         return 0;

    //     lua::function mFunc("Frame:has_script", pLua, 1);
    //     mFunc.add(0, "script name", lua::type::STRING);
    //     if (mFunc.check())
    //         mFunc.push(mSelf.can_use_script(mFunc.get(0)->get_string()));

    //     return mFunc.on_return();
    // }

    // /** @function is_clamped_to_screen
    // */
    // mClass.set_function("is_clamped_to_screen", [](frame& mSelf)
    // {
    //     if (!check_object_())
    //         return 0;

    //     lua::function mFunc("Frame:is_clamped_to_screen", pLua, 1);

    //     mFunc.push(mSelf.is_clamped_to_screen());

    //     return mFunc.on_return();
    // }

    // /** @function is_frame_type
    // */
    // mClass.set_function("is_frame_type", [](frame& mSelf)
    // {
    //     if (!check_object_())
    //         return 0;

    //     lua::function mFunc("Frame:is_frame_type", pLua, 1);
    //     mFunc.add(0, "Frame type", lua::type::STRING);
    //     if (mFunc.check())
    //     {
    //         if (mSelf.get_frame_type() == mFunc.get(0)->get_string())
    //             mFunc.push(bool(true));
    //         else
    //             mFunc.push(bool(false));
    //     }

    //     return mFunc.on_return();
    // }

    // /** @function is_keyboard_enabled
    // */
    // mClass.set_function("is_keyboard_enabled", [](frame& mSelf)
    // {
    //     if (!check_object_())
    //         return 0;

    //     lua::function mFunc("Frame:is_keyboard_enabled", pLua, 1);

    //     mFunc.push(mSelf.is_keyboard_enabled());

    //     return mFunc.on_return();
    // }

    // /** @function is_mouse_enabled
    // */
    // mClass.set_function("is_mouse_enabled", [](frame& mSelf)
    // {
    //     if (!check_object_())
    //         return 0;

    //     lua::function mFunc("Frame:is_mouse_enabled", pLua, 1);

    //     mFunc.push(mSelf.is_mouse_enabled());

    //     return mFunc.on_return();
    // }

    // /** @function is_mouse_wheel_enabled
    // */
    // mClass.set_function("is_mouse_wheel_enabled", [](frame& mSelf)
    // {
    //     if (!check_object_())
    //         return 0;

    //     lua::function mFunc("Frame:is_mouse_wheel_enabled", pLua, 1);

    //     mFunc.push(mSelf.is_mouse_wheel_enabled());

    //     return mFunc.on_return();
    // }

    // /** @function is_movable
    // */
    // mClass.set_function("is_movable", [](frame& mSelf)
    // {
    //     if (!check_object_())
    //         return 0;

    //     lua::function mFunc("Frame:is_movable", pLua, 1);

    //     mFunc.push(mSelf.is_movable());

    //     return mFunc.on_return();
    // }

    // /** @function is_resizable
    // */
    // mClass.set_function("is_resizable", [](frame& mSelf)
    // {
    //     if (!check_object_())
    //         return 0;

    //     lua::function mFunc("Frame:is_resizable", pLua, 1);

    //     mFunc.push(mSelf.is_resizable());

    //     return mFunc.on_return();
    // }

    // /** @function is_top_level
    // */
    // mClass.set_function("is_top_level", [](frame& mSelf)
    // {
    //     if (!check_object_())
    //         return 0;

    //     lua::function mFunc("Frame:is_top_level", pLua, 1);

    //     mFunc.push(mSelf.is_top_level());

    //     return mFunc.on_return();
    // }

    // /** @function is_user_placed
    // */
    // mClass.set_function("is_user_placed", [](frame& mSelf)
    // {
    //     if (!check_object_())
    //         return 0;

    //     lua::function mFunc("Frame:is_user_placed", pLua, 1);

    //     mFunc.push(mSelf.is_user_placed());

    //     return mFunc.on_return();
    // }

    // /** @function raise
    // */
    // mClass.set_function("raise", [](frame& mSelf)
    // {
    //     if (!check_object_())
    //         return 0;

    //     lua::function mFunc("Frame:raise", pLua);

    //     mSelf.raise();

    //     return mFunc.on_return();
    // }

    // /** @function register_all_events
    // */
    // mClass.set_function("register_all_events", [](frame& mSelf)
    // {
    //     if (!check_object_())
    //         return 0;

    //     lua::function mFunc("Frame:register_all_events", pLua);

    //     mSelf.register_all_events();

    //     return mFunc.on_return();
    // }

    // /** @function register_event
    // */
    // mClass.set_function("register_event", [](frame& mSelf)
    // {
    //     if (!check_object_())
    //         return 0;

    //     lua::function mFunc("Frame:register_event", pLua);
    //     mFunc.add(0, "event name", lua::type::STRING);
    //     if (mFunc.check())
    //         mSelf.register_event(mFunc.get(0)->get_string());

    //     return mFunc.on_return();
    // }

    // /** @function register_for_drag
    // */
    // mClass.set_function("register_for_drag", [](frame& mSelf)
    // {
    //     if (!check_object_())
    //         return 0;

    //     lua::function mFunc("Frame:register_for_drag", pLua);
    //     mFunc.add(0, "button 1", lua::type::STRING, true);
    //     mFunc.add(1, "button 2", lua::type::STRING, true);
    //     mFunc.add(2, "button 3", lua::type::STRING, true);
    //     if (mFunc.check())
    //     {
    //         std::vector<std::string> lButtonList;
    //         for (uint i = 0; i < 3; ++i)
    //         {
    //             if (mFunc.is_provided(i))
    //                 lButtonList.push_back(mFunc.get(i)->get_string());
    //             else
    //                 break;
    //         }
    //         mSelf.register_for_drag(lButtonList);
    //     }

    //     return mFunc.on_return();
    // }

    // /** @function set_backdrop
    // */
    // mClass.set_function("set_backdrop", [](frame& mSelf)
    // {
    //     if (!check_object_())
    //         return 0;

    //     lua::function mFunc("Frame:set_backdrop", pLua);
    //     mFunc.add(0, "backdrop table", lua::type::TABLE);
    //     mFunc.add(0, "nil", lua::type::NIL);
    //     if (mFunc.check())
    //     {
    //         if (mFunc.get(0)->get_type() == lua::type::NIL)
    //         {
    //             mSelf.set_backdrop(nullptr);
    //         }
    //         else
    //         {
    //             std::unique_ptr<backdrop> pBackdrop(new backdrop(get_object()));

    //             lua::state& mState = mFunc.get_state();
    //             manager* pManager = manager::get_manager(mState);

    //             pBackdrop->set_background(pManager->parse_file_name(mState.get_field_string("bgFile", false, "")));
    //             pBackdrop->set_edge(pManager->parse_file_name(mState.get_field_string("edgeFile", false, "")));
    //             pBackdrop->set_background_tilling(mState.get_field_bool("tile", false, false));

    //             float fTileSize = static_cast<float>(mState.get_field_double("tileSize", false, 0.0));
    //             if (fTileSize != 0)
    //                 pBackdrop->set_tile_size(fTileSize);

    //             float fEdgeSize = static_cast<float>(mState.get_field_double("edgeSize", false, 0.0));
    //             if (fEdgeSize != 0)
    //                 pBackdrop->set_edge_size(fEdgeSize);

    //             mState.get_field("insets");

    //             if (mState.get_type() == lua::type::TABLE)
    //             {
    //                 pBackdrop->set_background_insets(bounds2f(
    //                     mState.get_field_double("left",   false, 0),
    //                     mState.get_field_double("right",  false, 0),
    //                     mState.get_field_double("top",    false, 0),
    //                     mState.get_field_double("bottom", false, 0)
    //                 ));
    //             }

    //             mSelf.set_backdrop(std::move(pBackdrop));
    //         }
    //     }

    //     return mFunc.on_return();
    // }

    // /** @function set_backdrop_border_color
    // */
    // mClass.set_function("set_backdrop_border_color", [](frame& mSelf)
    // {
    //     if (!check_object_())
    //         return 0;

    //     lua::function mFunc("Frame:set_backdrop_border_color", pLua);
    //     mFunc.add(0, "red", lua::type::NUMBER);
    //     mFunc.add(1, "green", lua::type::NUMBER);
    //     mFunc.add(2, "blue", lua::type::NUMBER);
    //     mFunc.add(3, "alpha", lua::type::NUMBER, true);
    //     mFunc.new_param_set();
    //     mFunc.add(0, "color", lua::type::STRING);

    //     if (mFunc.check())
    //     {
    //         backdrop* pBackdrop = mSelf.get_backdrop();
    //         if (!pBackdrop)
    //         {
    //             mSelf.set_backdrop(std::unique_ptr<backdrop>(new backdrop(get_object())));
    //             pBackdrop = mSelf.get_backdrop();
    //         }

    //         color mColor;
    //         if (mFunc.get_param_set_rank() == 0)
    //         {
    //             if (mFunc.is_provided(3))
    //             {
    //                 mColor = color(
    //                     mFunc.get(0)->get_number(),
    //                     mFunc.get(1)->get_number(),
    //                     mFunc.get(2)->get_number(),
    //                     mFunc.get(3)->get_number()
    //                 );
    //             }
    //             else
    //             {
    //                 mColor = color(
    //                     mFunc.get(0)->get_number(),
    //                     mFunc.get(1)->get_number(),
    //                     mFunc.get(2)->get_number()
    //                 );
    //             }
    //         }
    //         else
    //             mColor = color(mFunc.get(0)->get_string());

    //         pBackdrop->set_edge_color(mColor);
    //     }

    //     return mFunc.on_return();
    // }

    // /** @function set_backdrop_color
    // */
    // mClass.set_function("set_backdrop_color", [](frame& mSelf)
    // {
    //     if (!check_object_())
    //         return 0;

    //     lua::function mFunc("Frame:set_backdrop_color", pLua);
    //     mFunc.add(0, "red", lua::type::NUMBER);
    //     mFunc.add(1, "green", lua::type::NUMBER);
    //     mFunc.add(2, "blue", lua::type::NUMBER);
    //     mFunc.add(3, "alpha", lua::type::NUMBER, true);
    //     mFunc.new_param_set();
    //     mFunc.add(0, "color", lua::type::STRING);

    //     if (mFunc.check())
    //     {
    //         backdrop* pBackdrop = mSelf.get_backdrop();
    //         if (!pBackdrop)
    //         {
    //             mSelf.set_backdrop(std::unique_ptr<backdrop>(new backdrop(get_object())));
    //             pBackdrop = mSelf.get_backdrop();
    //         }

    //         color mColor;
    //         if (mFunc.get_param_set_rank() == 0)
    //         {
    //             if (mFunc.is_provided(3))
    //             {
    //                 mColor = color(
    //                     mFunc.get(0)->get_number(),
    //                     mFunc.get(1)->get_number(),
    //                     mFunc.get(2)->get_number(),
    //                     mFunc.get(3)->get_number()
    //                 );
    //             }
    //             else
    //             {
    //                 mColor = color(
    //                     mFunc.get(0)->get_number(),
    //                     mFunc.get(1)->get_number(),
    //                     mFunc.get(2)->get_number()
    //                 );
    //             }
    //         }
    //         else
    //             mColor = color(mFunc.get(0)->get_string());

    //         pBackdrop->set_background_color(mColor);
    //     }

    //     return mFunc.on_return();
    // }


    // /** @function set_clamped_to_screen
    // */
    // mClass.set_function("set_clamped_to_screen", [](frame& mSelf)
    // {
    //     if (!check_object_())
    //         return 0;

    //     lua::function mFunc("Frame:set_clamped_to_screen", pLua);
    //     mFunc.add(0, "is clamped to screen", lua::type::BOOLEAN);
    //     if (mFunc.check())
    //         mSelf.set_clamped_to_screen(mFunc.get(0)->get_bool());

    //     return mFunc.on_return();
    // }

    // /** @function set_frame_level
    // */
    // mClass.set_function("set_frame_level", [](frame& mSelf)
    // {
    //     if (!check_object_())
    //         return 0;

    //     lua::function mFunc("Frame:set_frame_level", pLua);
    //     mFunc.add(0, "level", lua::type::NUMBER);
    //     if (mFunc.check())
    //         mSelf.set_level(mFunc.get(0)->get_int());

    //     return mFunc.on_return();
    // }

    // /** @function set_frame_strata
    // */
    // mClass.set_function("set_frame_strata", [](frame& mSelf)
    // {
    //     if (!check_object_())
    //         return 0;

    //     lua::function mFunc("Frame:set_frame_strata", pLua);
    //     mFunc.add(0, "strata", lua::type::STRING);
    //     if (mFunc.check())
    //         mSelf.set_frame_strata(mFunc.get(0)->get_string());

    //     return mFunc.on_return();
    // }

    // /** @function set_hit_rect_insets
    // */
    // mClass.set_function("set_hit_rect_insets", [](frame& mSelf)
    // {
    //     if (!check_object_())
    //         return 0;

    //     lua::function mFunc("Frame:set_hit_rect_insets", pLua);
    //     mFunc.add(0, "left", lua::type::NUMBER);
    //     mFunc.add(1, "right", lua::type::NUMBER);
    //     mFunc.add(2, "top", lua::type::NUMBER);
    //     mFunc.add(3, "bottom", lua::type::NUMBER);
    //     if (mFunc.check())
    //     {
    //         mSelf.set_abs_hit_rect_insets(
    //             mFunc.get(0)->get_number(),
    //             mFunc.get(1)->get_number(),
    //             mFunc.get(2)->get_number(),
    //             mFunc.get(3)->get_number()
    //         );
    //     }

    //     return mFunc.on_return();
    // }

    // /** @function set_max_resize
    // */
    // mClass.set_function("set_max_resize", [](frame& mSelf)
    // {
    //     if (!check_object_())
    //         return 0;

    //     lua::function mFunc("Frame:set_max_resize", pLua);
    //     mFunc.add(0, "width", lua::type::NUMBER);
    //     mFunc.add(1, "height", lua::type::NUMBER);
    //     if (mFunc.check())
    //     {
    //         mSelf.set_max_resize(
    //             mFunc.get(0)->get_number(),
    //             mFunc.get(1)->get_number()
    //         );
    //     }

    //     return mFunc.on_return();
    // }

    // /** @function set_min_resize
    // */
    // mClass.set_function("set_min_resize", [](frame& mSelf)
    // {
    //     if (!check_object_())
    //         return 0;

    //     lua::function mFunc("Frame:set_min_resize", pLua);
    //     mFunc.add(0, "width", lua::type::NUMBER);
    //     mFunc.add(1, "height", lua::type::NUMBER);
    //     if (mFunc.check())
    //     {
    //         mSelf.set_min_resize(
    //             mFunc.get(0)->get_number(),
    //             mFunc.get(1)->get_number()
    //         );
    //     }

    //     return mFunc.on_return();
    // }

    // /** @function set_max_width
    // */
    // mClass.set_function("set_max_width", [](frame& mSelf)
    // {
    //     if (!check_object_())
    //         return 0;

    //     lua::function mFunc("Frame:set_max_width", pLua);
    //     mFunc.add(0, "width", lua::type::NUMBER);
    //     if (mFunc.check())
    //     {
    //         mSelf.set_max_width(
    //             mFunc.get(0)->get_number()
    //         );
    //     }

    //     return mFunc.on_return();
    // }

    // /** @function set_max_height
    // */
    // mClass.set_function("set_max_height", [](frame& mSelf)
    // {
    //     if (!check_object_())
    //         return 0;

    //     lua::function mFunc("Frame:set_max_height", pLua);
    //     mFunc.add(0, "height", lua::type::NUMBER);
    //     if (mFunc.check())
    //     {
    //         mSelf.set_max_height(
    //             mFunc.get(0)->get_number()
    //         );
    //     }

    //     return mFunc.on_return();
    // }

    // /** @function set_min_width
    // */
    // mClass.set_function("set_min_width", [](frame& mSelf)
    // {
    //     if (!check_object_())
    //         return 0;

    //     lua::function mFunc("Frame:set_min_width", pLua);
    //     mFunc.add(0, "width", lua::type::NUMBER);
    //     if (mFunc.check())
    //     {
    //         mSelf.set_min_width(
    //             mFunc.get(0)->get_number()
    //         );
    //     }

    //     return mFunc.on_return();
    // }

    // /** @function set_min_height
    // */
    // mClass.set_function("set_min_height", [](frame& mSelf)
    // {
    //     if (!check_object_())
    //         return 0;

    //     lua::function mFunc("Frame:set_min_height", pLua);
    //     mFunc.add(0, "height", lua::type::NUMBER);
    //     if (mFunc.check())
    //     {
    //         mSelf.set_min_height(
    //             mFunc.get(0)->get_number()
    //         );
    //     }

    //     return mFunc.on_return();
    // }

    // /** @function set_movable
    // */
    // mClass.set_function("set_movable", [](frame& mSelf)
    // {
    //     if (!check_object_())
    //         return 0;

    //     lua::function mFunc("Frame:set_movable", pLua);
    //     mFunc.add(0, "is movable", lua::type::BOOLEAN);
    //     if (mFunc.check())
    //         mSelf.set_movable(mFunc.get(0)->get_bool());

    //     return mFunc.on_return();
    // }

    // /** @function set_resizable
    // */
    // mClass.set_function("set_resizable", [](frame& mSelf)
    // {
    //     if (!check_object_())
    //         return 0;

    //     lua::function mFunc("Frame:set_resizable", pLua);
    //     mFunc.add(0, "is resizable", lua::type::BOOLEAN);
    //     if (mFunc.check())
    //         mSelf.set_resizable(mFunc.get(0)->get_bool());

    //     return mFunc.on_return();
    // }

    // /** @function set_scale
    // */
    // mClass.set_function("set_scale", [](frame& mSelf)
    // {
    //     if (!check_object_())
    //         return 0;

    //     lua::function mFunc("Frame:set_scale", pLua);
    //     mFunc.add(0, "scale", lua::type::NUMBER);
    //     if (mFunc.check())
    //         mSelf.set_scale(mFunc.get(0)->get_number());

    //     return mFunc.on_return();
    // }

    // /** @function set_script
    // */
    // mClass.set_function("set_script", [](frame& mSelf)
    // {
    //     if (!check_object_())
    //         return 0;

    //     lua::function mFunc("Frame:set_script", pLua);
    //     mFunc.add(0, "script name", lua::type::STRING);
    //     mFunc.add(1, "function", lua::type::FUNCTION, true);
    //     mFunc.add(1, "nil", lua::type::NIL, true);
    //     if (mFunc.check())
    //     {
    //         std::string sScriptName = mFunc.get(0)->get_string();
    //         if (mSelf.can_use_script(sScriptName))
    //         {
    //             lua::state& mState = mFunc.get_state();
    //             lua::argument* pArg = mFunc.get(1);
    //             if (pArg->is_provided() && pArg->get_type() == lua::type::FUNCTION)
    //             {
    //                 mSelf.set_script(sScriptName,
    //                     sol::protected_function(sol::reference(mState.get_state(), pArg->get_index())));
    //             }
    //             else
    //             {
    //                 mSelf.remove_script(sScriptName);
    //             }
    //         }
    //         else
    //         {
    //             gui::out << gui::error << mSelf.get_frame_type() << " : "
    //                 << "\"" << mSelf.get_name() << "\" cannot use script \""
    //                 << sScriptName << "\"." << std::endl;
    //         }
    //     }

    //     return mFunc.on_return();
    // }

    // /** @function set_top_level
    // */
    // mClass.set_function("set_top_level", [](frame& mSelf)
    // {
    //     if (!check_object_())
    //         return 0;

    //     lua::function mFunc("Frame:set_top_level", pLua);
    //     mFunc.add(0, "is top level", lua::type::BOOLEAN);
    //     if (mFunc.check())
    //         mSelf.set_top_level(mFunc.get(0)->get_bool());

    //     return mFunc.on_return();
    // }

    // /** @function set_user_placed
    // */
    // mClass.set_function("set_user_placed", [](frame& mSelf)
    // {
    //     if (!check_object_())
    //         return 0;

    //     lua::function mFunc("Frame:set_user_placed", pLua);
    //     mFunc.add(0, "is user placed", lua::type::BOOLEAN);
    //     if (mFunc.check())
    //         mSelf.set_user_placed(mFunc.get(0)->get_bool());

    //     return mFunc.on_return();
    // }

    // /** @function start_moving
    // */
    // mClass.set_function("start_moving", [](frame& mSelf)
    // {
    //     if (!check_object_())
    //         return 0;

    //     lua::function mFunc("Frame:start_moving", pLua);

    //     mSelf.start_moving();

    //     return mFunc.on_return();
    // }

    // /** @function start_sizing
    // */
    // mClass.set_function("start_sizing", [](frame& mSelf)
    // {
    //     if (!check_object_())
    //         return 0;

    //     lua::function mFunc("Frame:start_sizing", pLua);
    //     mFunc.add(0, "point", lua::type::STRING);
    //     if (mFunc.check())
    //         mSelf.start_sizing(anchor::get_anchor_point(mFunc.get(0)->get_string()));

    //     return mFunc.on_return();
    // }

    // /** @function stop_moving_or_sizing
    // */
    // mClass.set_function("stop_moving_or_sizing", [](frame& mSelf)
    // {
    //     if (!check_object_())
    //         return 0;

    //     lua::function mFunc("Frame:stop_moving_or_sizing", pLua);

    //     mSelf.stop_moving();
    //     mSelf.stop_sizing();

    //     return mFunc.on_return();
    // }

    // /** @function unregister_all_events
    // */
    // mClass.set_function("unregister_all_events", [](frame& mSelf)
    // {
    //     if (!check_object_())
    //         return 0;

    //     lua::function mFunc("Frame:unregister_all_events", pLua);

    //     mSelf.unregister_all_events();

    //     return mFunc.on_return();
    // }

    // /** @function unregister_event
    // */
    // mClass.set_function("unregister_event", [](frame& mSelf)
    // {
    //     if (!check_object_())
    //         return 0;

    //     lua::function mFunc("Frame:unregister_event", pLua);
    //     mFunc.add(0, "event name", lua::type::STRING);
    //     if (mFunc.check())
    //         mSelf.unregister_event(mFunc.get(0)->get_string());

    //     return mFunc.on_return();
    // }
}

}
}
