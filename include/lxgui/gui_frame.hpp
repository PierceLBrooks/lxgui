#ifndef LXGUI_GUI_FRAME_HPP
#define LXGUI_GUI_FRAME_HPP

#include <lxgui/lxgui.hpp>
#include "lxgui/gui_region.hpp"
#include "lxgui/gui_backdrop.hpp"
#include "lxgui/gui_layeredregion.hpp"
#include "lxgui/gui_event.hpp"
#include "lxgui/gui_eventreceiver.hpp"

#include <lxgui/utils.hpp>
#include <lxgui/utils_view.hpp>

#include <sol/protected_function.hpp>

#include <set>
#include <list>
#include <functional>
#include <limits>
#include <unordered_map>
#include <vector>

namespace lxgui {
namespace gui
{
    class frame_renderer;
    class frame;

    /// Contains gui::layered_region
    struct layer
    {
        layer();

        bool bDisabled;
        std::vector<utils::observer_ptr<layered_region>> lRegionList;

        static layer_type get_layer_type(const std::string& sLayer);
    };

    /// Holds file/line information for a script.
    struct script_info
    {
        std::string sFileName;
        uint uiLineNbr = 0;
    };

    /// C++ function type for UI script handlers.
    using script_handler_function = std::function<void(frame&, const event_data&)>;

    /// Disconnectable slot for script handlers (used internally).
    struct script_handler_slot
    {
        script_handler_function mCallback;
        bool bDisconnected = false;
    };

    /// A #uiobject that can contain other objects and react to events.
    /** This class, which is at the core of the UI design, can contain
    *   other frames as "children", and layered regions sorted by layers
    *   (text, images, ...). A frame can also react to events, and register
    *   callbacks to be executed on particular events (key presses, etc.)
    *   or on every tick.
    *
    *   Each frame has an optional "title region", which can be used to
    *   define and draw a title bar. This title bar can then be used to
    *   move the frame around the screen using mouse click and drag.
    *   Furthermore, frames have optional support for resizing by click
    *   and drag on corners or edges (opt in).
    *
    *   Frames can either move freely on the screen, or be "clamped" to the
    *   screen so they cannot be partly outside of their render area.
    *
    *   __Rendering.__ Frames are grouped into different "strata", which are
    *   rendered sequentially. Frames in a high strata will always be rendered
    *   above frames in a low strata. Then, within a strata, frames are further
    *   sorted by "level"; within this particular strata, a frame with a high
    *   level will always be rendered above all frames with a lower level, but
    *   it will still remain below other frames in a higher strata. The level
    *   of a frame is automatically set to the maximum level inside the strata
    *   when the frame is clicked, which effectively brings the frame to the
    *   front.
    *
    *   __Children and regions.__ When a frame is hidden, all its children
    *   and regions will also be hidden. Likewise, deleting a frame will
    *   automatically delete all its children and regions, unless they are
    *   detached first. Other than this, children and regions do not need to
    *   be located inside the frame; this is controlled purely by their anchors.
    *   Therefore, if a child is not anchored to its parent, moving the parent
    *   will not automatically move the child.
    *
    *   __Events.__ Frames can react to events. For this to happen, a callback
    *   function must be registered to handle the corresponding event. There are
    *   two types of events. First: hard-coded UI events such as `OnKeyPress`
    *   or `OnUpdate`, which are automatically triggered by lxgui. Second:
    *   generic events, which can be triggered from various sources and all
    *   forwarded to the `OnEvent` callback. Generic events are typically
    *   generated by whatever application is being driven by lxgui (i.e., your
    *   game), and they enable application-specific behavior (for example:
    *   changing the UI when the player is under attack will likely require an
    *   `"UNDER_ATTACK"` event).
    *
    *   To use the first type of events (hard-coded events), all you have to
    *   do in general is register a callback function using frame::set_script.
    *   However, some hard-coded events require explicit enabling. In particular:
    *
    *   - Events related to keyboard input (`OnKeyDown`, `OnKeyUp`) require
    *   frame::enable_keyboard.
    *   - Events related to mouse input (`OnDragStart`, `OnDragStop`, `OnEnter`,
    *   `OnLeave`, `OnMouseUp`, `OnMouseDown`, `OnMouseWheel`, `OnReceiveDrag`)
    *   require frame::enable_mouse.
    *
    *   To use the second type of events (generic events), you have to register
    *   a callback for `OnEvent` _and_ register the frame for each generic event
    *   you wish to listen to. This is done with frame::register_event.
    *
    *   Some events provide arguments to the registered callback function. For
    *   example, the application can fire a `"UNIT_ATTACKED"` event when a unit
    *   is under attack, and pass the ID of the attacked unit as a first argument,
    *   and the ID of the attacker as a second argument. If a callback
    *   function is registered using frame::set_script, these arguments can be
    *   handled and named like regular function parameters. In XML callback
    *   handlers, they can be accessed with the hard-coded generic names `arg1`,
    *   `arg2`, etc.
    *
    *   Hard-coded events available to all frames:
    *
    *   - `OnDragStart`: Triggered when one of the mouse button registered for
    *   dragging (see frame::register_for_drag) has been pressed inside the
    *   area of the screen occupied by the frame, and a mouse movement is first
    *   recorded.
    *   - `OnEnter`: Triggered when the mouse pointer enters into the area of
    *   the screen occupied by the frame. Note: this only takes into account the
    *   position and size of the frame and its title region, but not the space
    *   occupied by its children or layered regions. Will not trigger if the
    *   frame is hidden.
    *   - `OnEvent`: Triggered when a registered generic event occurs. See
    *   frame::register_event. To allow distinguishing which event has just
    *   been fired, the registered callback function is always provided with a
    *   first argument that is set to a string matching the event name. Further
    *   arguments can be passed to the callback and are handled as for other events.
    *   - `OnHide`: Triggered when uiobject::hide is called, or when the frame
    *   is hidden indirectly (for example if its parent is itself hidden). This
    *   will only fire if the frame was previously shown.
    *   - `OnKeyDown`: Triggered when any keyboard key is pressed. Will not
    *   trigger if the frame is hidden. This event provides two arguments to
    *   the registered callback: a number identifying the key, and the
    *   human-readable name of the key.
    *   - `OnKeyUp`: Triggered when any keyboard key is released. Will not
    *   trigger if the frame is hidden. This event provides two arguments to
    *   the registered callback: a number identifying the key, and the
    *   human-readable name of the key.
    *   - `OnLeave`: Triggered when the mouse pointer leaves the area of the
    *   screen occupied by the frame. Note: this only takes into account the
    *   position and size of the frame and its title region, but not the space
    *   occupied by its children or layered regions. Will not trigger if the
    *   frame is hidden, unless the frame was just hidden with the mouse
    *   previously inside the frame.
    *   - `OnLoad`: Triggered just after the frame is created. This is where
    *   you would normally register for events and specific inputs, set up
    *   initial states for extra logic, or do localization.
    *   - `OnMouseDown`: Triggered when any mouse button is pressed. Will not
    *   trigger if the frame is hidden. This event provides one argument to
    *   the registered callback: a string identifying the mouse button
    *   (`"LeftButton"`, `"RightButton"`, or `"MiddleButton"`).
    *   - `OnMouseUp`: Triggered when any mouse button is released. Will not
    *   trigger if the frame is hidden. This event provides one argument to
    *   the registered callback: a string identifying the mouse button
    *   (`"LeftButton"`, `"RightButton"`, or `"MiddleButton"`).
    *   - `OnMouseWheel`: Triggered when the mouse wheel is moved. This event
    *   provides one argument to the registered callback: a number indicating by
    *   how many "notches" the wheel has turned in this event. A positive value
    *   means the wheel has been moved "away" from the user (this would normally
    *   scroll *up* in a document).
    *   - `OnReceiveDrag`: Triggered when the mouse pointer was previously
    *   dragged onto the frame, and when one of the mouse button registered for
    *   dragging (see frame::register_for_drag) is released. This enables
    *   the "drop" in "drag and drop" operations.
    *   - `OnShow`: Triggered when uiobject::show is called, or when the frame
    *   is shown indirectly (for example if its parent is itself shown). This
    *   will only fire if the frame was previously hidden.
    *   - `OnSizeChanged`: Triggered whenever the size of the frame changes, either
    *   directly or indirectly. Be very careful not to call any function that could
    *   change the size of the frame inside this callback, as this would generate
    *   an infinite loop.
    *   - `OnUpdate`: Triggered on every tick of the game loop. This event provides
    *   one argument to the registered callback: a floating point number indicating
    *   how much time has passed since the last call to `OnUpdate` (in seconds).
    *   For optimal performance, prefer using other events types whenever possible.
    *   `OnUpdate` callbacks will be executed over and over again, and can quickly
    *   consume a lot of resources if user unreasonably. If you have to use
    *   `OnUpdate`, you can mitigate performance problems by artificially reducing
    *   the update rate: let the callback function only accumulate the time passed,
    *   and wait until enough time has passed (say, half a second) to execute any
    *   expensive operation. Then reset the accumulated time, and wait again.
    *
    *   Generic events fired natively by lxgui:
    *
    *   - `"LUA_ERROR"`: Triggered whenever a callback function or an addon script
    *   file generates a Lua error. This event provides one argument to the
    *   registered callback: a string containing the error message.
    *   - `"ADDON_LOADED"`: Triggered when an addon is fully loaded. This event
    *   provides one argument to the registered callback: a string containing the
    *   name of the loaded addon.
    *   - `"ENTERING_WORLD"`: Triggered once at the start of the program, at the
    *   end of the first update tick.
    *
    *   __Virtual frames.__ Virtual frames are not displayed on the screen,
    *   and technically are not part of the interface. They are only available
    *   as "templates" that can be reused by other (virtual or non-virtual)
    *   frames. This is useful for defining a few frame templates with a
    *   particular style, and then reuse these templates across the interface
    *   to ensure a consistent look. When inheriting from a virtual frame,
    *   the inheriting frame will copy all the registered callbacks, all the
    *   child frames, and all the layered regions of the virtual frame.
    */
    class frame : public event_receiver, public region
    {
    public :

        /// Type of the frame child list (internal).
        /** \note Constraints on the choice container type:
        *          - must not invalidate iterators on back insertion
        *          - must allow forward iteration
        *          - iterators can be invalidated on removal
        *          - most common use is iteration, not addition or removal
        *          - ordering of elements is irrelevant
        */
        using child_list = std::list<utils::owner_ptr<frame>>;
        using child_list_view = utils::view::adaptor<child_list,
            utils::view::smart_ptr_dereferencer,
            utils::view::non_null_filter>;
        using const_child_list_view = utils::view::adaptor<const child_list,
            utils::view::smart_ptr_dereferencer,
            utils::view::non_null_filter>;

        /// Type of the region list (internal).
        /** \note Constraints on the choice container type:
        *          - must not invalidate iterators on back insertion
        *          - must allow forward iteration
        *          - iterators can be invalidated on removal
        *          - most common use is iteration, not addition or removal
        *          - ordering of elements is irrelevant
        */
        using region_list = std::list<utils::owner_ptr<layered_region>>;
        using region_list_view = utils::view::adaptor<region_list,
            utils::view::smart_ptr_dereferencer,
            utils::view::non_null_filter>;
        using const_region_list_view = utils::view::adaptor<const region_list,
            utils::view::smart_ptr_dereferencer,
            utils::view::non_null_filter>;

        template<typename BaseIterator>
        struct script_handler_dereferencer
        {
            using data_type = const script_handler_function&;
            static data_type dereference(const BaseIterator& mIter) { return mIter->mCallback; }
        };

        template<typename BaseIterator>
        struct non_disconnected_filter
        {
            static bool is_included(const BaseIterator& mIter) { return !mIter->bDisconnected; }
        };

        /// Type of the script handler list (internal).
        /** \note Constraints on the choice container type:
        *          - must not invalidate iterators on back insertion
        *          - must allow forward iteration
        *          - iterators cannot be invalidated on removal
        *          - most common use is iteration, not addition or removal
        *          - ordering of elements is relevant
        */
        using script_handler_list = std::list<script_handler_slot>;
        using script_list_view = utils::view::adaptor<script_handler_list,
            script_handler_dereferencer,
            non_disconnected_filter>;

        /// Constructor.
        explicit frame(manager& mManager);

        /// Destructor.
        ~frame() override;

        /// Renders this widget on the current render target.
        void render() const override;

        /// Updates this widget's logic.
        /** \param fDelta Time spent since last update
        *   \note Triggered callbacks could destroy the frame. If you need
        *         to use the frame again after calling this function, use
        *         the helper class alive_checker.
        */
        void update(float fDelta) override;

        /// Prints all relevant information about this widget in a string.
        /** \param sTab The offset to give to all lines
        *   \return All relevant information about this widget
        */
        std::string serialize(const std::string& sTab) const override;

        /// Returns 'true' if this frame can use a script.
        /** \param sScriptName The name of the script
        *   \note This method can be overriden if needed.
        */
        virtual bool can_use_script(const std::string& sScriptName) const;

        /// Checks if this frame's position is valid.
        void check_position() const;

        /// Copies an uiobject's parameters into this frame (inheritance).
        /** \param mObj The uiobject to copy
        */
        void copy_from(const uiobject& mObj) override;

        /// Creates a new title region for this frame.
        /** \note You can get it by calling get_title_region().
        */
        void create_title_region();

        /// Disables a layer.
        /** \param mLayerID The id of the layer to disable
        */
        void disable_draw_layer(layer_type mLayerID);

        /// Enables a layer.
        /** \param mLayerID The id of the layer to enable
        */
        void enable_draw_layer(layer_type mLayerID);

        /// Sets if this frame can receive keyboard input.
        /** \param bIsKeyboardEnabled 'true' to enable
        */
        virtual void enable_keyboard(bool bIsKeyboardEnabled);

        /// Sets if this frame can receive mouse input.
        /** \param bIsMouseEnabled 'true' to enable
        *   \param bAllowWorldInput 'true' to allow world input
        */
        virtual void enable_mouse(bool bIsMouseEnabled, bool bAllowWorldInput = false);

        /// Sets if this frame can receive mouse wheel input.
        /** \param bIsMouseWheelEnabled 'true' to enable
        */
        virtual void enable_mouse_wheel(bool bIsMouseWheelEnabled);

        /// Checks if this frame has a script defined.
        /** \param sScriptName The name of the script to check
        *   \return 'true' if this script is defined
        */
        bool has_script(const std::string& sScriptName) const;

        /// Adds a layered_region to this frame's children.
        /** \param pRegion The layered_region to add
        */
        utils::observer_ptr<layered_region> add_region(utils::owner_ptr<layered_region> pRegion);

        /// Adds a layered_region to this frame's children.
        /** \param pRegion The layered_region to add
        */
        template<typename region_type, typename enable =
            typename std::enable_if<std::is_base_of<gui::layered_region, region_type>::value>::type>
        utils::observer_ptr<region_type> add_region(utils::owner_ptr<region_type> pRegion)
        {
            return utils::static_pointer_cast<region_type>(add_region(
                utils::static_pointer_cast<layered_region>(std::move(pRegion))));
        }

        /// Removes a layered_region from this frame's children.
        /** \param pRegion The layered_region to remove
        *   \return A unique_ptr to the region, ignore it to destroy the region.
        */
        utils::owner_ptr<layered_region> remove_region(
            const utils::observer_ptr<layered_region>& pRegion);

        /// Creates a new region as child of this frame.
        /** \param mLayer       The layer on which to create the region
        *   \param sClassName   The name of the region class ("FontString", ...)
        *   \param sName        The name of the region
        *   \param lInheritance The objects to inherit from
        *   \return The created region.
        *   \note You don't have the reponsibility to delete this region.
        *         It will be done automatically when its parent is deleted.
        *   \note This function takes care of the basic initializing :
        *         you can directly use the created region.
        */
        utils::observer_ptr<layered_region> create_region(
            layer_type mLayer, const std::string& sClassName, const std::string& sName,
            const std::vector<utils::observer_ptr<const uiobject>>& lInheritance = {}
        );

        /// Creates a new region as child of this frame.
        /** \param mLayer       The layer on which to create the region
        *   \param sName        The name of the region
        *   \param lInheritance The objects to inherit from
        *   \return The created region.
        *   \note You don't have the reponsibility to delete this region.
        *         It will be done automatically when its parent is deleted.
        *   \note This function takes care of the basic initializing :
        *         you can directly use the created region.
        */
        template<typename region_type, typename enable =
            typename std::enable_if<std::is_base_of<gui::layered_region, region_type>::value>::type>
        utils::observer_ptr<region_type> create_region(layer_type mLayer, const std::string& sName,
            const std::vector<utils::observer_ptr<const uiobject>>& lInheritance = {})
        {
            return utils::static_pointer_cast<region_type>(create_region(
                mLayer, region_type::CLASS_NAME, sName, lInheritance));
        }

        /// Creates a new frame as child of this frame.
        /** \param sClassName   The name of the frame class ("Button", ...)
        *   \param sName        The name of the frame
        *   \param lInheritance The objects to inherit from
        *   \return The created frame.
        *   \note You don't have the reponsibility to delete this frame.
        *         It will be done automatically when its parent is deleted.
        *   \note This function takes care of the basic initializing :
        *         you can directly use the created frame. However, you still
        *         need to call notify_loaded() when you are done with any extra
        *         initialization you require on this frame. If you do not,
        *         the frame's OnLoad callback will not fire.
        */
        utils::observer_ptr<frame> create_child(
            const std::string& sClassName, const std::string& sName,
            const std::vector<utils::observer_ptr<const uiobject>>& lInheritance = {});

        /// Creates a new frame as child of this frame.
        /** \param sName        The name of the frame
        *   \param lInheritance The objects to inherit from
        *   \return The created frame.
        *   \note You don't have the reponsibility to delete this frame.
        *         It will be done automatically when its parent is deleted.
        *   \note This function takes care of the basic initializing :
        *         you can directly use the created frame.
        */
        template<typename frame_type, typename enable =
            typename std::enable_if<std::is_base_of<gui::frame, frame_type>::value>::type>
        utils::observer_ptr<frame_type> create_child(const std::string& sName,
            const std::vector<utils::observer_ptr<const uiobject>>& lInheritance = {})
        {
            return utils::static_pointer_cast<frame_type>(create_child(
                frame_type::CLASS_NAME, sName, lInheritance));
        }

        /// Adds a frame to this frame's children.
        /** \param pChild The frame to add
        */
        utils::observer_ptr<frame> add_child(utils::owner_ptr<frame> pChild);

        /// Adds a frame to this frame's children.
        /** \param pChild The frame to add
        */
        template<typename frame_type, typename enable =
            typename std::enable_if<std::is_base_of<gui::frame, frame_type>::value>::type>
        utils::observer_ptr<frame_type> add_child(utils::owner_ptr<frame_type> pChild)
        {
            return utils::static_pointer_cast<frame_type>(add_child(
                utils::static_pointer_cast<frame>(std::move(pChild))));
        }

        /// Removes a frame from this frame's children.
        /** \param pChild The frame to remove
            \return A unique_ptr to the child, ignore it to destroy the child.
        */
        utils::owner_ptr<frame> remove_child(const utils::observer_ptr<frame>& pChild);

        /// Returns the child list.
        /** \return The child list
        */
        child_list_view get_children();

        /// Returns the child list.
        /** \return The child list
        */
        const_child_list_view get_children() const;

        /// Returns one of this frame's children.
        /** \param sName The name of the child
        *   \return One of this frame's children
        *   \note The provided name can either be the full name or the relative name
        *         (i.e. without the "$parent" in front). This function first looks
        *         for matches on the full name, then if no child is found, on the
        *         relative name.
        */
        utils::observer_ptr<const frame> get_child(const std::string& sName) const;

        /// Returns one of this frame's children.
        /** \param sName The name of the child
        *   \return One of this frame's children
        *   \note The provided name can either be the full name or the relative name
        *         (i.e. without the "$parent" in front). This function first looks
        *         for matches on the full name, then if no child is found, on the
        *         relative name.
        */
        utils::observer_ptr<frame> get_child(const std::string& sName)
        {
            return utils::const_pointer_cast<frame>(
                const_cast<const frame*>(this)->get_child(sName));
        }

        /// Returns one of this frame's children.
        /** \param sName The name of the child
        *   \return One of this frame's children
        *   \note The provided name can either be the full name or the relative name
        *         (i.e. without the "$parent" in front). This function first looks
        *         for matches on the full name, then if no child is found, on the
        *         relative name.
        */
        template<typename frame_type, typename enable =
            typename std::enable_if<std::is_base_of<gui::frame, frame_type>::value>::type>
        utils::observer_ptr<const frame_type> get_child(const std::string& sName) const
        {
            return down_cast<frame_type>(get_child(sName));
        }

        /// Returns one of this frame's children.
        /** \param sName The name of the child
        *   \return One of this frame's children
        *   \note The provided name can either be the full name or the relative name
        *         (i.e. without the "$parent" in front). This function first looks
        *         for matches on the full name, then if no child is found, on the
        *         relative name.
        */
        template<typename frame_type, typename enable =
            typename std::enable_if<std::is_base_of<gui::frame, frame_type>::value>::type>
        utils::observer_ptr<frame_type> get_child(const std::string& sName)
        {
            return down_cast<frame_type>(get_child(sName));
        }

        /// Returns the region list.
        /** \return The region list
        */
        region_list_view get_regions();

        /// Returns the region list.
        /** \return The region list
        */
        const_region_list_view get_regions() const;

        /// Returns one of this frame's region.
        /** \param sName The name of the region
        *   \return One of this frame's region
        *   \note The provided name can either be the full name or the relative name
        *         (i.e. without the "$parent" in front). This function first looks
        *         for matches on the full name, then if no region is found, on the
        *         relative name.
        */
        utils::observer_ptr<const layered_region> get_region(const std::string& sName) const;

        /// Returns one of this frame's region.
        /** \param sName The name of the region
        *   \return One of this frame's region
        *   \note The provided name can either be the full name or the relative name
        *         (i.e. without the "$parent" in front). This function first looks
        *         for matches on the full name, then if no region is found, on the
        *         relative name.
        */
        utils::observer_ptr<layered_region> get_region(const std::string& sName)
        {
            return utils::const_pointer_cast<layered_region>(
                const_cast<const frame*>(this)->get_region(sName));
        }

        /// Returns one of this frame's region.
        /** \param sName The name of the region
        *   \return One of this frame's region
        *   \note The provided name can either be the full name or the relative name
        *         (i.e. without the "$parent" in front). This function first looks
        *         for matches on the full name, then if no region is found, on the
        *         relative name.
        */
        template<typename region_type, typename enable =
            typename std::enable_if<std::is_base_of<gui::layered_region, region_type>::value>::type>
        utils::observer_ptr<region_type> get_region(const std::string& sName)
        {
            return down_cast<region_type>(get_region(sName));
        }

        /// Calculates effective alpha.
        /** \return Effective alpha (alpha*parent->alpha)
        */
        float get_effective_alpha() const;

        /// Calculates effective scale.
        /** \return Effective scale (scale*parent->scale)
        */
        float get_effective_scale() const;

        /// Returns this frame's level.
        /** \return This frame's level
        */
        int get_level() const;

        /// Returns this frame's strata.
        /** \return This frame's strata
        */
        frame_strata get_frame_strata() const;

        /// Returns this frame's backdrop.
        /** \return This frame's backdrop
        */
        const backdrop* get_backdrop() const;

        /// Returns this frame's backdrop.
        /** \return This frame's backdrop
        */
        backdrop* get_backdrop();

        /// Returns this frame's backdrop, creating it if needed
        /** \return This frame's backdrop
        */
        backdrop& get_or_create_backdrop();

        /// Returns this frame's type.
        /** \return This frame's type (Frame, Slider, ...)
        */
        const std::string& get_frame_type() const;

        /// Returns this frame's absolute hit rect insets.
        /** \return This frame's absolute hit rect insets
        */
        const bounds2f& get_abs_hit_rect_insets() const;

        /// Returns this frame's relative hit rect insets.
        /** \return This frame's relative hit rect insets
        */
        const bounds2f& get_rel_hit_rect_insets() const;

        /// Returns this frame's max dimensions.
        /** \return This frame's max dimensions
        */
        vector2f get_max_resize() const;

        /// Returns this frame's min dimensions.
        /** \return This frame's min dimensions
        */
        vector2f get_min_resize() const;

        /// Returns the number of children of this frame.
        /** \return The number of children of this frame
        *   \note If only an approximate number is acceptable, use get_rough_num_children(),
        *         which is faster.
        */
        uint get_num_children() const;

        /// Returns the approximate number of children of this frame.
        /** \return The approximate number of children of this frame
        *   \note The returned number is an *upper bound* on the actual number of children.
        *         This can be used to reserve enough space for memory allocations.
        *         If the exact number of children is required, use get_num_children().
        */
        uint get_rough_num_children() const;

        /// Returns the number of regions of this frame.
        /** \return The number of regions of this frame
        *   \note If only an approximate number is acceptable, use get_rough_num_regions(),
        *         which is faster.
        */
        uint get_num_regions() const;

        /// Returns the approximate number of regions of this frame.
        /** \return The approximate number of regions of this frame
        *   \note The returned number is an *upper bound* on the actual number of regions.
        *         This can be used to reserve enough space for memory allocations.
        *         If the exact number of regions is required, use get_num_regions().
        */
        uint get_rough_num_regions() const;

        /// Returns this frame's scale.
        /** \return This frame's scale
        *   \note If you want it's true scale on the screen,
        *         use get_effective_scale().
        */
        float get_scale() const;

        /// Returns this frame's title region.
        utils::observer_ptr<const region> get_title_region() const { return pTitleRegion_; }

        /// Returns this frame's title region.
        utils::observer_ptr<region> get_title_region() { return pTitleRegion_; }

        /// Checks if this frame is clamped to screen.
        /** \return 'true' if this frame is clamed to screen
        */
        bool is_clamped_to_screen() const;

        /// Checks if the provided coordinates are in the frame.
        /** \param mPosition The coordinates to test
        *   \return 'true' if the provided coordinates are in the frame
        */
        virtual bool is_in_frame(const vector2f& mPosition) const;

        /// Checks if this frame can receive keyboard input.
        /** \return 'true' if this frame can receive keyboard input
        */
        bool is_keyboard_enabled() const;

        /// Checks if this frame can receive mouse input.
        /** \return 'true' if this frame can receive mouse input
        */
        bool is_mouse_enabled() const;

        /// Checks if this frame allows world input.
        /** \return 'true' if this frame allows world input
        */
        bool is_world_input_allowed() const;

        /// Checks if this frame can receive mouse wheel input.
        /** \return 'true' if this frame can receive mouse wheel input
        */
        bool is_mouse_wheel_enabled() const;

        /// Checks if this frame can be moved.
        /** \return 'true' if this frame can be moved
        */
        bool is_movable() const;

        /// Checks if this frame can be resized.
        /** \return 'true' if this frame can be resized
        */
        bool is_resizable() const;

        /// Checks if this frame is at top level.
        /** \return 'true' if this frame is at top level
        */
        bool is_top_level() const;

        /// Checks if this frame has been moved by the user.
        /** \return 'true' if this frame has been moved by the user
        */
        bool is_user_placed() const;

        /// Returns the "adjusted" script name: "OnEvent" becomes "on_event"
        /** \param sScriptName The CamelCase name of the script
        *   \return the snake_case name of the script
        */
        static std::string get_adjusted_script_name(const std::string& sScriptName);

        /// Adds an additional handler script to this frame (executed after existing scripts).
        /** \param sScriptName The name of the script (e.g., "OnEvent")
        *   \param sContent    The content ot the script, as Lua code
        *   \param mInfo       The location where this script has been defined
        *   \note The script_info parameter is used only for displaying error messages.
        *         This function is meant to be used by the XML parser. If you want to manually
        *         define your own script handlers, prefer the other overloads.
        */
        void add_script(const std::string& sScriptName, const std::string& sContent,
            const script_info& mInfo = script_info{})
        {
            define_script_(sScriptName, sContent, true, mInfo);
        }

        /// Adds an additional handler script to this frame (executed after existing scripts).
        /** \param sScriptName The name of the script (e.g., "OnEvent")
        *   \param mHandler    The handler of the script, as a Lua function
        *   \param mInfo       The location where this script has been defined
        *   \note This defines a Lua function to be called for the event specified in sScriptName.
        *         This provides more flexibility compared to using C++ function, but also has a
        *         larger overhead. If performance is a concern, prefer the other overload taking a
        *         C++ function instead.
        */
        void add_script(const std::string& sScriptName, sol::protected_function mHandler,
            const script_info& mInfo = script_info{})
        {
            define_script_(sScriptName, std::move(mHandler), true, mInfo);
        }

        /// Adds an additional handler script to this frame (executed after existing scripts).
        /** \param sScriptName The name of the script (e.g., "OnEvent")
        *   \param mHandler    The handler of the script, as a C++ function
        *   \param mInfo       The location where this script has been defined
        *   \note This defines a C++ function to be called for the event specified in sScriptName.
        *         This provides the best performance, but lacks direct access to the Lua
        *         environment. If this is required, prefer the other overload taking a Lua function
        *         instead.
        */
        void add_script(const std::string& sScriptName, script_handler_function mHandler,
            const script_info& mInfo = script_info{})
        {
            define_script_(sScriptName, std::move(mHandler), true, mInfo);
        }

        /// Sets a new handler script for this frame (replacing existing scripts).
        /** \param sScriptName The name of the script (e.g., "OnEvent")
        *   \param sContent    The content ot the script, as Lua code
        *   \param mInfo       The location where this script has been defined
        *   \note The script_info parameter is used only for displaying error messages.
        *         This function is meant to be used by the XML parser. If you want to manually
        *         define your own script handlers, prefer the other overloads.
        */
        void set_script(const std::string& sScriptName, const std::string& sContent,
            const script_info& mInfo = script_info{})
        {
            define_script_(sScriptName, sContent, false, mInfo);
        }

        /// Sets a new handler script for this frame (replacing existing scripts).
        /** \param sScriptName The name of the script (e.g., "OnEvent")
        *   \param mHandler    The handler of the script, as a Lua function
        *   \param mInfo       The location where this script has been defined
        *   \note This defines a Lua function to be called for the event specified in sScriptName.
        *         This provides more flexibility compared to using C++ function, but also has a
        *         larger overhead. If performance is a concern, prefer the other overload taking a
        *         C++ function instead.
        */
        void set_script(const std::string& sScriptName, sol::protected_function mHandler,
            const script_info& mInfo = script_info{})
        {
            define_script_(sScriptName, std::move(mHandler), false, mInfo);
        }

        /// Sets a new handler script for this frame (replacing existing scripts).
        /** \param sScriptName The name of the script (e.g., "OnEvent")
        *   \param mHandler    The handler of the script, as a C++ function
        *   \param mInfo       The location where this script has been defined
        *   \note This defines a C++ function to be called for the event specified in sScriptName.
        *         This provides the best performance, but lacks direct access to the Lua
        *         environment. If this is required, prefer the other overload taking a Lua function
        *         instead.
        */
        void set_script(const std::string& sScriptName, script_handler_function mHandler,
            const script_info& mInfo = script_info{})
        {
            define_script_(sScriptName, std::move(mHandler), false, mInfo);
        }

        /// Return a view into this frame's handler scripts, registered for the given event.
        /** \param sScriptName The name of the script (e.g., "OnEvent")
        *   \return An iterable view into the frame's handlers.
        */
        script_list_view get_script(const std::string& sScriptName) const;

        /// Removes a script from this frame.
        /** \param sScriptName The name of the script (e.g., "OnEvent")
        *   \note This removes all handler scripts registered to this event, including the ones inherited
        *         from templates.
        */
        void remove_script(const std::string& sScriptName);

        /// Calls a script.
        /** \param sScriptName The name of the script (e.g., "OnEvent")
        *   \param mData       Stores scripts arguments
        *   \note Triggered callbacks could destroy the frame. If you need
        *         to use the frame again after calling this function, use
        *         the helper class alive_checker.
        */
        virtual void on_script(const std::string& sScriptName, const event_data& mData = event_data{});

        /// Calls the on_event script.
        /** \param mEvent The Event that occured
        *   \note Triggered callbacks could destroy the frame. If you need
        *         to use the frame again after calling this function, use
        *         the helper class alive_checker.
        */
        void on_event(const event& mEvent) override;

        /// Tells this frame to react to every event in the game.
        void register_all_events();

        /// Tells this frame to react to a certain event.
        /** \param sEventName The name of the event
        */
        void register_event(const std::string& sEventName) override;

        /// Tells this frame to react to mouse drag.
        /** \param lButtonList The list of mouse button allowed
        */
        void register_for_drag(const std::vector<std::string>& lButtonList);

        /// Sets if this frame is clamped to screen.
        /** \param bIsClampedToScreen 'true' if this frame is clamped to screen
        *   \note If 'true', the frame can't go out of the screen.
        */
        void set_clamped_to_screen(bool bIsClampedToScreen);

        /// Sets this frame's strata.
        /** \param mStrata The new strata
        */
        void set_frame_strata(frame_strata mStrata);

        /// Sets this frame's strata.
        /** \param sStrata The new strata
        */
        void set_frame_strata(const std::string& sStrata);

        /// Sets this frames' backdrop.
        /** \param pBackdrop The new backdrop
        */
        void set_backdrop(std::unique_ptr<backdrop> pBackdrop);

        /// Sets this frame's absolute hit rect insets.
        /** \param lInsets Offsets
        *   \note This is the zone on which you can click.
        */
        void set_abs_hit_rect_insets(const bounds2f& lInsets);

        /// Sets this frame's relative hit rect insets.
        /** \param lInsets Offsets
        *   \note This is the zone on which you can click.
        */
        void set_rel_hit_rect_insets(const bounds2f& lInsets);

        /// Sets this frame's level.
        /** \param iLevel The new level
        */
        void set_level(int iLevel);

        /// Sets this frame's maximum size.
        /** \param mMax The maximum dimensions of this frame
        */
        void set_max_resize(const vector2f& mMax);

        /// Sets this frame's minimum size.
        /** \param mMin Minimum dimensions of this frame
        */
        void set_min_resize(const vector2f& mMin);

        /// Sets this frame's maximum height.
        /** \param fMaxHeight The maximum height this frame can have
        */
        void set_max_height(float fMaxHeight);

        /// Sets this frame's maximum width.
        /** \param fMaxWidth  The maximum width this frame can have
        */
        void set_max_width(float fMaxWidth);

        /// Sets this frame's minimum height.
        /** \param fMinHeight The minimum height this frame can have
        */
        void set_min_height(float fMinHeight);

        /// Sets this frame's minimum width.
        /** \param fMinWidth  The minimum width this frame can have
        */
        void set_min_width(float fMinWidth);

        /// Sets if this frame can be moved by the user.
        /** \param bIsMovable 'true' to allow the user to move this frame
        */
        void set_movable(bool bIsMovable);

        /// Removes this widget from its parent and return an owning pointer.
        /** \return An owning pointer to this widget
        */
        utils::owner_ptr<uiobject> release_from_parent() override;

        /// Sets if this frame can be resized by the user.
        /** \param bIsResizable 'true' to allow the user to resize this frame
        */
        void set_resizable(bool bIsResizable);

        /// Sets this frame's scale.
        /** \param fScale The new scale
        */
        void set_scale(float fScale);

        /// Sets if this frame is at top level.
        /** \param bIsTopLevel 'true' to put the frame at top level
        */
        void set_top_level(bool bIsTopLevel);

        /// Increases this frame's level so it's the highest of the strata.
        /** \note All its children are raised of the same ammount.
        *   \note Only works for top level frames.
        */
        void raise();

        /// Sets if this frame has been moved by the user.
        /** \param bIsUserPlaced 'true' if this frame has been moved by the user
        */
        void set_user_placed(bool bIsUserPlaced);

        /// Starts moving this frame with the mouse.
        void start_moving();

        /// ends moving this frame.
        void stop_moving();

        /// Starts resizing this frame with the mouse.
        /** \param mPoint The corner to move
        */
        void start_sizing(const anchor_point& mPoint);

        /// ends resizing this frame.
        void stop_sizing();

        /// shows this widget.
        /** \note Its parent must be shown for it to appear on
        *         the screen.
        */
        void show() override;

        /// hides this widget.
        /** \note All its children won't be visible on the screen
        *         anymore, even if they are still marked as shown.
        */
        void hide() override;

        /// shows/hides this widget.
        /** \param bIsShown 'true' if you want to show this widget
        *   \note See show() and hide() for more infos.
        *   \note Contrary to show() and hide(), this function doesn't
        *         trigger any event ("OnShow" or "OnHide"). It should
        *         only be used to set the initial state of the widget.
        */
        void set_shown(bool bIsShown) override;

        /// Flags this object as rendered by another object.
        /** \param pRenderer The object that will take care of rendering this widget
        *   \note By default, objects are rendered by the gui::manager.
        *   \note The renderer also takes care of providing inputs.
        *   \note If the renderer is set to nullptr, the frame will inherit the renderer of its
        *         parent. If the frame has no parent, this will default to the gui::manager.
        */
        void set_renderer(utils::observer_ptr<frame_renderer> pRenderer);

        /// Returns the renderer of this object, nullptr if none.
        /** \return The renderer of this object, nullptr if none
        *   \note For more informations, see set_renderer().
        */
        utils::observer_ptr<const frame_renderer> get_renderer() const { return pRenderer_; }

        /// Returns the renderer of this object, nullptr if none.
        /** \return The renderer of this object, nullptr if none
        *   \note For more informations, see set_renderer().
        */
        const utils::observer_ptr<frame_renderer>& get_renderer() { return pRenderer_; }

        /// Returns the renderer of this object or its parents, nullptr if none.
        /** \return The renderer of this object or its parents, nullptr if none
        *   \note For more informations, see set_renderer().
        */
        utils::observer_ptr<const frame_renderer> get_top_level_renderer() const final;

        /// Returns the renderer of this object or its parents, nullptr if none.
        /** \return The renderer of this object or its parents, nullptr if none
        *   \note For more informations, see set_renderer().
        */
        utils::observer_ptr<frame_renderer> get_top_level_renderer()
        {
            return utils::const_pointer_cast<frame_renderer>(
                const_cast<const frame*>(this)->get_top_level_renderer());
        }

        /// Notifies the renderer of this widget that it needs to be redrawn.
        /** \note Automatically called by any shape changing function.
        */
        void notify_renderer_need_redraw() const override;

        /// Changes this widget's absolute dimensions (in pixels).
        /** \param mDimensions The new dimensions
        */
        void set_dimensions(const vector2f& mDimensions) override;

        /// Changes this widget's absolute width (in pixels).
        /** \param fAbsWidth The new width
        */
        void set_width(float fAbsWidth) override;

        /// Changes this widget's absolute height (in pixels).
        /** \param fAbsHeight The new height
        */
        void set_height(float fAbsHeight) override;

        /// Tells this frame it is being overed by the mouse.
        /** \param bMouseInFrame 'true' if the mouse is above this frame
        *   \param mMousePos     The mouse coordinates in pixels
        *   \note Always use the mouse position set by this function and
        *         not the one returned by the input_manager, because there
        *         can be an offset applied (for example with scroll_frame).
        */
        virtual void notify_mouse_in_frame(bool bMouseInFrame, const vector2f& mMousePos);

        /// Notifies this widget that it is now visible on screen.
        /** \param bTriggerEvents Set to false to disable OnShow/OnHide events
        *   \note Automatically called by show()/hide().
        */
        void notify_visible(bool bTriggerEvents = true) override;

        /// Notifies this widget that it is no longer visible on screen.
        /** \param bTriggerEvents Set to false to disable OnShow/OnHide events
        *   \note Automatically called by show()/hide().
        */
        void notify_invisible(bool bTriggerEvents = true) override;

        /// Notifies this widget that it has been fully loaded.
        /** \note Calls the "OnLoad" script.
        */
        void notify_loaded() override;

        /// Tells this frame to rebuild its layer list.
        /** \note Automatically called by add_region(), remove_region(), and
        *         layered_region::set_draw_layer().
        */
        void notify_layers_need_update();

        /// Tells this widget that the global interface scaling factor has changed.
        void notify_scaling_factor_updated() override;

        /// Tells the frame not to react to all events.
        void unregister_all_events();

        /// Tells the frame not to react to a certain event.
        /** \param sEventName The name of the event
        */
        void unregister_event(const std::string& sEventName) override;

        /// Sets the addon this frame belongs to.
        /** \param pAddOn The addon this frame belongs to
        */
        void set_addon(const addon* pAddOn);

        /// Returns this frame's addon.
        /** \return This frame's addon
        *   \note Returns "nullptr" if the frame has been created
        *         by Lua code and wasn't assigned a parent.
        */
        const addon* get_addon() const;

        /// Creates the associated Lua glue.
        void create_glue() override;

        /// Parses data from an xml::block.
        /** \param pBlock The frame's xml::block
        *   \note Derived classes must override parse_all_blocks_before_children_() if
        *         they need to parse additional blocks, and parse_attributes_() if they
        *         need to parse additional attributes.
        */
        void parse_block(xml::block* pBlock) final;

        /// Registers this widget class to the provided Lua state
        static void register_on_lua(sol::state& mLua);

        static constexpr const char* CLASS_NAME = "Frame";

    protected :

        // XML parsing
        void parse_attributes_(xml::block* pBlock) override;
        virtual void parse_all_blocks_before_children_(xml::block* pBlock);
        virtual void parse_resize_bounds_block_(xml::block* pBlock);
        virtual void parse_title_region_block_(xml::block* pBlock);
        virtual void parse_backdrop_block_(xml::block* pBlock);
        virtual void parse_hit_rect_insets_block_(xml::block* pBlock);
        virtual void parse_layers_block_(xml::block* pBlock);
        virtual void parse_frames_block_(xml::block* pBlock);
        virtual void parse_scripts_block_(xml::block* pBlock);

        virtual void notify_top_level_parent_(bool bTopLevel,
            const utils::observer_ptr<frame>& pParent);

        void add_level_(int iAmount);

        void propagate_renderer_(bool bRendered);

        void update_borders_() const override;
        void update_mouse_in_frame_();

        void define_script_(const std::string& sScriptName, const std::string& sContent,
            bool bAppend, const script_info& mInfo);

        void define_script_(const std::string& sScriptName, sol::protected_function mHandler,
            bool bAppend, const script_info& mInfo);

        void define_script_(const std::string& sScriptName, script_handler_function mHandler,
            bool bAppend, const script_info& mInfo);

        child_list  lChildList_;
        region_list lRegionList_;

        static constexpr uint num_layers = static_cast<uint>(layer_type::ENUM_SIZE);

        std::array<layer,num_layers> lLayerList_;

        std::unordered_map<std::string, std::shared_ptr<script_handler_list>> lScriptHandlerList_;

        std::vector<std::string> lQueuedEventList_;
        std::set<std::string>    lRegEventList_;
        std::set<std::string>    lRegDragList_;

        const addon* pAddOn_ = nullptr;

        int iLevel_ = 0;

        frame_strata               mStrata_ = frame_strata::MEDIUM;
        bool                       bIsTopLevel_ = false;
        utils::observer_ptr<frame> pTopLevelParent_ = nullptr;

        utils::observer_ptr<frame_renderer> pRenderer_ = nullptr;

        std::unique_ptr<backdrop> pBackdrop_;

        bool bHasAllEventsRegistred_ = false;

        bool bIsKeyboardEnabled_ = false;
        bool bIsMouseEnabled_ = false;
        bool bAllowWorldInput_ = false;
        bool bIsMouseWheelEnabled_ = false;
        bool bIsMovable_ = false;
        bool bIsClampedToScreen_ = false;
        bool bIsResizable_ = false;
        bool bIsUserPlaced_ = false;

        bool bBuildLayerList_ = false;

        bounds2f lAbsHitRectInsetList_ = bounds2f::ZERO;
        bounds2f lRelHitRectInsetList_ = bounds2f::ZERO;

        float fMinWidth_ = 0.0f;
        float fMaxWidth_ = std::numeric_limits<float>::infinity();
        float fMinHeight_ = 0.0f;
        float fMaxHeight_ = std::numeric_limits<float>::infinity();

        vector2f mOldSize_;

        float fScale_ = 1.0f;

        bool bMouseInFrame_ = false;
        bool bMouseInTitleRegion_ = false;
        vector2f mMousePos_;

        utils::owner_ptr<region> pTitleRegion_ = nullptr;

        bool bMouseDraggedInFrame_ = false;
    };
}
}

#endif
